# quickSort 快速排序

## 作业对应的文件

随机数据 random_int （10万个int，取值在0~32767之间）

快排排序结果 result_q （含排序时间）

排序函数的代码 ./include/qsort.h ./src/qsort.c （quicksort( )函数的实现）

## 快速排序 伪代码

```pseudo
algorithm quicksort(A, lo, hi)
        if lo < hi then
            p ← partition(A, lo, hi)
            quicksort(A, lo, p – 1)
            quicksort(A, p + 1, hi)
```

分区函数方案一：

```pseudo
algorithm partition(A, lo, hi)
        pivot ← A[hi]
        i ← lo
        for j ← lo to hi – 1 do
        if A[j] ≤ pivot then
            swap A[i] with A[j]
            i ← i + 1
        swap A[i] with A[hi]
        return i
```

分区函数方案二：

```pseudo
algorithm partition(A, lo, hi)
    pivot ← A[lo + (hi - lo) / 2]
    i ← lo - 1
    j ← hi + 1
    loop forever
        do
            i ← i + 1
        while A[i] < pivot
        do
            j ← j - 1
        while A[j] > pivot
        if i >= j then
            return j
        swap A[i] with A[j]
```

## 我干了什么↓

1. 随机产生100,000个整数写入到random_int文件中，将排序结果和时间写到result文件里

--------------------------------------------------

三种快排方案及对应的写入文件：

- 纯快排 **result_q**

- 插入快排 递归到数组规模较小（<50）时就改为插入排序 **result_insertq**\
    规模较小时插排可以显著减少递归次数，不过过多的插排会拖累速度

- 多线程插入快排，在插入快排的基础上利用多线程 **result_multi**\
    应该比插入快排更快

参照组：

- 纯插排 **result_insert**

### 结果

排序100,000个整数的时间（一个一个运行，排序同一组数据）

多线程插入快排(3.206 ms) < 插入快排(5.246 ms) ≈ 纯快排(5.731 ms) < 纯插排(1438 ms)

**注** 这里多线程插排改成了数组大小10,000以上开线程，而不是命令行测试的100,000以上开线程
（毕竟数据总量也就100,000，那样的话实际上就不是多线程了）

*之前一起运行，结果由于编译器玄学优化，给我整了个纯插排62 us出来，懵了半天（真就半天*

2. 更大规模数据的排序

rand()随机产生整数存入全局数组中，利用test()来检查是否升序，用interval()测量时间

--------------------------------------------------

我觉得文件玄学(**我不信多线程速度倒数**)，所以写了个main1.c试试在命令行下运行的结果\
 *主要是对文件I/O没什么信心，而且文件太多也不太好*

### 结果

结果制表如下，原始数据截图在testPic下

| 数据规模(百万) | 多线程插入快排 | 插入快排 |  纯快排  |  纯插排  |
| :------------: | :------------: | :------: | :------: | :------: |
|      0.1       |    0.0055 s    | 0.0070 s | 0.0101 s | 1.3963 s |
|       1        |    0.0216 s    | 0.0778 s | 0.0895 s | > 3 min  |
|       10       |    0.534 s     | 4.831 s  | 4.832 s  |   暴毙   |

#### 除去纯插排后继续测试（去掉插排后整体排序效率有所增加(?)）

| 数据规模(百万) | 多线程插入快排 | 插入快排 | 纯快排  |
| :------------: | :------------: | :------: | :-----: |
|       10       |    0.177 s     | 1.702 s  | 2.114 s |
|      100       |    1.703 s     | 99.05 s  | 132.7 s |
|     \* 400     |    7.754 s     |    --    |   --    |

* 500百万以上的数据规模，不能再直接创建全局数组变量来获得了：
编译会报错，就算编译出来了也无法运行

可以看到将最后小块排序改用插排确实对性能有所提升，而且多线程能够极大提升排序效率，这与直觉相符

--------------------------------------------------

## 之前的玄学结果(

纯插排(62 us) < 插入快排(585 us) < 多线程插入快排(1.058 ms) < 纯快排(5.790 ms)

？？？ 插排真有真么快么

UPDATED 2020.06.03 19:48

破案了，是编译器玄学优化的锅，就不该让他们一起运行...

之前插排放在了最后运行，所以大概就被优化成直接用之前的缓冲了（
结果越早运行的越慢

## 实际排序效率↓（一个一个运行，排序同一组数据）

多线程插入快排(3.206 ms) < 插入快排(5.246 ms) ≈ 纯快排(5.731 ms) < 纯插排(1438 ms)
